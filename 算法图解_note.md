# 算法图解

## 第1章 算法简介

### 1.2 二分查找

从中间开始查找

二分查找是一种算法，其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null.

```python
使用简单查找法查找元素时，在最糟情况下需要查看每个元素。因此，如果列表包含8个数字，你最多需要检查8个数字。
而使用二分查找时，最多需要检查log n个元素。如果列表包含8个元素，你最多需要
检查3个元素，因为log 8 = 3（2 3 = 8）。如果列表包含1024个元素，你最多需要检查10个元素，因为log 1024 = 10（2 10 =1024）。
```

仅当列表是有序的时候，二分查找才管用.

### 1.3 大 O 表示法

#### 1.3.1 算法的运行时间以不同的速度增加

大O表示法指出了算法有多快。例如，假设列表包含n个元素。简单查找需要检查每个元素，因此需要执行n次操作。使用大O表示法，这个运行时间为O(n)。单位秒呢？没有——大O表示法指的并非以秒为单位的速度。大O表示法让你能够比较操作数，它指出了算法运行时间的增速。
再来看一个例子。为检查长度为n的列表，二分查找需要执行log n次操作。使用大O表示法，这个运行时间怎么表示呢？O(log n)。一般而言，大O表示法像下面这样。

假设检查一个元素需要1毫秒。使用简单查找时，Bob必须检查100个元素，因此需要100毫秒才能查找完毕。而使用二分查找时，只需检查7个元素（log2100大约为7），因此需要7毫秒就能查找完毕

Bob使用包含10亿个元素的列表运行二分查找，运行时间为30毫秒（log21 000 000 000大约30.列表包含10亿个元素时，简单查找需要10亿毫秒，相当于11天.

因为二分查找和简单查找的运行时间的增速不同。

#### 1.3.4 一些常见的大 O 运行时间

下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。
 O(log n)，也叫对数时间，这样的算法包括二分查找。
 O(n)，也叫线性时间，这样的算法包括简单查找。
 O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。
 O(n2
)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。
 O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。

## 第2章 选择排序

### 2.1 内存的工作原理

需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。但它们并非都适用于所有的情形，因此知道它们的差别很重要

### 2.2 数组和链表

使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）

#### 2.2.1 链表

链表中的元素可存储在内存的任何地方。

链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。

#### 2.2.2 数组

链表存在类似的问题。在需要读取链表的最后一个元素时，你不能直接读取，因为你不知道它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3的地址，以此类推，直到访问最后一个元素。需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低。

数组与此不同：你知道其中每个元素的地址。

需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素的地址，以此类推，直到访问第五个元素。

#### 2.2.3 术语

数组的元素带编号，编号从0而不是1开始.

元素的位置称为索引.

#### 2.2.4 在中间插入

使用链表时，插入元素很简单，只需修改它前面的那个元素指向的地址。而使用数组时，则必须将后面的元素都向后移。
如果没有足够的空间，可能还得将整个数组复制到其他地方！因此，当需要在中间插入元素时，链表是更好的选择。

#### 2.2.5 删除

链表只需修改前一个元素指向的地址即可。而使用数组时，删除元素后，必须将后面的元素都向前移。

数组用得很多，因为它支持随机访问。有两种访问方式：随机访问和顺序访问。顺序访问意味着从第一个元素开始逐个地读取元素。链表只能顺序访问：要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。随机访问意味着可直接跳到第十个元素。本书经常说数组的读取速度更快，这是因为它们支持随机访问。很多情况都要求能够随机访问，因此数组用得很多。

### 2.3 选择排序

O(n)时间意味着查看列表中的每个元素一次。

要找出播放次数最多的乐队，必须检查列表中的每个元素。正如你刚才看到的，这需要的时间为O(n)。因此对于这种时间为O(n)的操作，你需要执行n次。

需要的总时间为 O(n × n)，即O(n2)。

选择排序是一种灵巧的算法，但其速度不是很快。快速排序是一种更快的排序算法，其运行时间为O(n log n).

## 第3章 递归

### 3.1 递归

```python
def look_for_key(main_box):
    pile = main_box.make_a_pile_to_look_through()
    while pile is not empty:
        box = pile.grab_a_box()
        for item in box:
            if item.is_a_box():
                pile.append(item)
            elif item.is_a_key():
                print "found the key!"
```

```python
#第二种方法使用递归——函数调用自己，这种方法的伪代码如下。
def look_for_key(box):
    for item in box:
        if item.is_a_box():
            #递归
            look_for_key(item)
        elif item.is_a_key():
            print "found the key!" 
```

### 3.2 基线条件和递归条件

每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。

```python
def countdown(i):
    print i
    if i <= 0:  #基线条件
        return
    else:       #递归条件
        countdown(i-1) 
```

### 3.3 栈

调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都还在内存中。执行完函数greet2后，你回到函数greet，并从离开的地方开始接着往下执行：首先打印getting ready to say bye…，再调用函数bye.

#### 3.3.2 递归调用栈

```python
#阶乘的递归函数
def fact(x):
 if x == 1:
    return 1
 else:
    return x * fact(x-1)
```

## 第4章 快速排序

### 4.1 分而治之

```python
def sum(arr):
 total = 0
 for x in arr:
    total += x
 return total
print sum([1, 2, 3, 4])
```

从数组中选择一个元素，这个元素被称为基准值（pivot）。

这被称为分区（partitioning）: 一个由所有小于基准值的数字组成的子数组； 基准值； 一个由所有大于基准值的数组组成的子数组。

```python
#要对这两个子数组进行快速排序，再合并结果，就能得到一个有序数组！
quicksort([15, 10]) + [33] + quicksort([])
> [10, 15, 33]
```

(1) 选择基准值。
(2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。
(3) 对这两个子数组进行快速排序。

```python
下面是快速排序的代码。
def quicksort(array):
    if len(array) < 2:
        return array        #基线条件：为空或只包含一个元素的数组是“有序”的
    else:
        pivot = array[0]    #递归条件
        less = [i for i in array[1:] if i <= pivot]     #由所有小于基准值的元素组成的子数组
        greater = [i for i in array[1:] if i > pivot]   #由所有大于基准值的元素组成的子数组
        return quicksort(less) + [pivot] + quicksort(greater)

print quicksort([10, 5, 2, 3])
```

## 第5章 散列表

### 5.1 散列函数

散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。

```python
#使用函数dict来创建散列表
>>> book = dict()

>>> book["apple"] = 0.67
>>> book["milk"] = 1.49
>>> book["avocado"] = 1.49
>>> print book
{'avocado': 1.49, 'apple': 0.67, 'milk': 1.49}

>>> print book["avocado"]   #查询鳄梨的价格
1.49
```

散列表由键和值组成。在前面的散列表book中，键为商品名，值为商品价格。散列表将键映射到值.

```python
>>> phone_book = dict() #phone_book = ()与phone_book = dict()等效
>>> phone_book["jenny"] = 8675309
>>> phone_book["emergency"] = 911

>>> print phone_book["jenny"]
867530
```

#### 5.2.2 防止重复

```python
#如果名字在名单中，就说明这个人投过票了
voted = {}
def check_voter(name):
    if voted.get(name):
        print "kick them out!"
    else:
        voted[name] = True
        print "let them vote!"

>>> check_voter("tom")
let them vote!
>>> check_voter("mike")
let them vote!
>>> check_voter("mike")
kick them out! 
```

#### 5.2.3 将散列表用作缓存

```python
cache = {}
def get_page(url):
    if cache.get(url):
        return cache[url]       #返回缓存的数据
    else:
        data = get_data_from_server(url)
        cache[url] = data       #先将数据保存到缓存中
        return data 
```

### 5.3 冲突

给两个键分配的位置相同 :冲突

如果散列表存储的链表很长，散列表的速度将急剧下降

### 5.4 性能

#### 5.4.1 填装因子

```python
散列表的填装因子为2/5,即0.4 #5位置总数,2散列表包含的元素数
```

填装因子大于1意味着商品数量超过了数组的位置数。一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度.

你首先创建一个更长的新数组：通常将数组增长一倍.

填装因子越低，发生冲突的可能性越小，散列表的性能越高.

## 第6章 广度优先搜索

搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。

队列是一种先进先出的数据结构,而栈是后进先出的数据结构.

广度优先搜索将找出最短路径.(到终点段数最少的路径)

## 第七章 狄克斯特拉算法

段数最少的路径不一定是最快的.

在狄克斯特拉算法中,给每段都分配一个数字或权重,狄克斯特拉算法找出总权重最小的路径.

## 第8章 贪婪算法

```python
#集合不能包含重复的元素
>>> arr = [1, 2, 2, 3, 3, 3]
set(arr)
set([1, 2, 3])
```

并集意味着将集合合并。
交集意味着找出两个集合中都有的元素。
差集意味着将从一个集合中剔除出现在另一个集合中的元素。

```python
>>> fruits = set(["avocado", "tomato", "banana"])
>>> vegetables = set(["beets", "carrots", "tomato"])
#并集
>>> fruits | vegetables
set(["avocado", "beets", "carrots", "tomato", "banana"])
#交集
>>> fruits & vegetables
set(["tomato"])
#差集
>>> fruits – vegetables
set(["avocado", "banana"])

>>> vegetables – fruits
```

## 第9章 动态规划

动态规划先解决子问题，再逐步解决大问题.

## 第 10 章 K最近邻算法

在这三个邻居中，橙子比柚子多，因此这个水果很可能是橙子。祝贺你，你刚就是使用K最近邻

## 第 11 章 接下来如何做

### 11.1 树

二叉查找树类:其中的每个节点，左子节点的值都比它小，而右子节点的值都比它大

### 11.5 MapReduce 

#### 11.5.2 映射函数

映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理

```python
#将数组的每个元素翻倍
>>> arr1 = [1, 2, 3, 4, 5]
>>> arr2 = map(lambda x: 2 * x, arr1)
[2, 4, 6, 8, 10]
```

#### 11.5.3 归并函数

归并是将一个数组转换为一个元素

```python
>>> arr1 = [1, 2, 3, 4, 5]
>>> reduce(lambda x,y: x+y, arr1)
15 
```

## 2021-12-25

数组 : 连续,大小固定
链表 : 不连续,大小不固定.链表中每个元素都存储了下一个元素的地址.

`and` : 都为true 才为true,返回最后一个为true的,返回第一个为false的
`or` : 有一个为true,就为true
